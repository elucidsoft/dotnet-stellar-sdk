// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

namespace stellar_dotnet_sdk.xdr;

// === xdr source ============================================================

//  union SCVal switch (SCValType type)
//  {
//  
//  case SCV_BOOL:
//      bool b;
//  case SCV_VOID:
//      void;
//  case SCV_ERROR:
//      SCError error;
//  
//  case SCV_U32:
//      uint32 u32;
//  case SCV_I32:
//      int32 i32;
//  
//  case SCV_U64:
//      uint64 u64;
//  case SCV_I64:
//      int64 i64;
//  case SCV_TIMEPOINT:
//      TimePoint timepoint;
//  case SCV_DURATION:
//      Duration duration;
//  
//  case SCV_U128:
//      UInt128Parts u128;
//  case SCV_I128:
//      Int128Parts i128;
//  
//  case SCV_U256:
//      UInt256Parts u256;
//  case SCV_I256:
//      Int256Parts i256;
//  
//  case SCV_BYTES:
//      SCBytes bytes;
//  case SCV_STRING:
//      SCString str;
//  case SCV_SYMBOL:
//      SCSymbol sym;
//  
//  // Vec and Map are recursive so need to live
//  // behind an option, due to xdrpp limitations.
//  case SCV_VEC:
//      SCVec *vec;
//  case SCV_MAP:
//      SCMap *map;
//  
//  case SCV_ADDRESS:
//      SCAddress address;
//  
//  // Special SCVals reserved for system-constructed contract-data
//  // ledger keys, not generally usable elsewhere.
//  case SCV_LEDGER_KEY_CONTRACT_INSTANCE:
//      void;
//  case SCV_LEDGER_KEY_NONCE:
//      SCNonceKey nonce_key;
//  
//  case SCV_CONTRACT_INSTANCE:
//      SCContractInstance instance;
//  };

//  ===========================================================================
public class SCVal
{
    public SCValType Discriminant { get; set; } = new();

    public bool B { get; set; }
    public SCError Error { get; set; }
    public Uint32 U32 { get; set; }
    public Int32 I32 { get; set; }
    public Uint64 U64 { get; set; }
    public Int64 I64 { get; set; }
    public TimePoint Timepoint { get; set; }
    public Duration Duration { get; set; }
    public UInt128Parts U128 { get; set; }
    public Int128Parts I128 { get; set; }
    public UInt256Parts U256 { get; set; }
    public Int256Parts I256 { get; set; }
    public SCBytes Bytes { get; set; }
    public SCString Str { get; set; }
    public SCSymbol Sym { get; set; }
    public SCVec Vec { get; set; }
    public SCMap Map { get; set; }
    public SCAddress Address { get; set; }
    public SCNonceKey NonceKey { get; set; }
    public SCContractInstance Instance { get; set; }

    public static void Encode(XdrDataOutputStream stream, SCVal encodedSCVal)
    {
        stream.WriteInt((int)encodedSCVal.Discriminant.InnerValue);
        switch (encodedSCVal.Discriminant.InnerValue)
        {
            case SCValType.SCValTypeEnum.SCV_BOOL:
                stream.WriteInt(encodedSCVal.B ? 1 : 0);
                break;
            case SCValType.SCValTypeEnum.SCV_VOID:
                break;
            case SCValType.SCValTypeEnum.SCV_ERROR:
                SCError.Encode(stream, encodedSCVal.Error);
                break;
            case SCValType.SCValTypeEnum.SCV_U32:
                Uint32.Encode(stream, encodedSCVal.U32);
                break;
            case SCValType.SCValTypeEnum.SCV_I32:
                Int32.Encode(stream, encodedSCVal.I32);
                break;
            case SCValType.SCValTypeEnum.SCV_U64:
                Uint64.Encode(stream, encodedSCVal.U64);
                break;
            case SCValType.SCValTypeEnum.SCV_I64:
                Int64.Encode(stream, encodedSCVal.I64);
                break;
            case SCValType.SCValTypeEnum.SCV_TIMEPOINT:
                TimePoint.Encode(stream, encodedSCVal.Timepoint);
                break;
            case SCValType.SCValTypeEnum.SCV_DURATION:
                Duration.Encode(stream, encodedSCVal.Duration);
                break;
            case SCValType.SCValTypeEnum.SCV_U128:
                UInt128Parts.Encode(stream, encodedSCVal.U128);
                break;
            case SCValType.SCValTypeEnum.SCV_I128:
                Int128Parts.Encode(stream, encodedSCVal.I128);
                break;
            case SCValType.SCValTypeEnum.SCV_U256:
                UInt256Parts.Encode(stream, encodedSCVal.U256);
                break;
            case SCValType.SCValTypeEnum.SCV_I256:
                Int256Parts.Encode(stream, encodedSCVal.I256);
                break;
            case SCValType.SCValTypeEnum.SCV_BYTES:
                SCBytes.Encode(stream, encodedSCVal.Bytes);
                break;
            case SCValType.SCValTypeEnum.SCV_STRING:
                SCString.Encode(stream, encodedSCVal.Str);
                break;
            case SCValType.SCValTypeEnum.SCV_SYMBOL:
                SCSymbol.Encode(stream, encodedSCVal.Sym);
                break;
            case SCValType.SCValTypeEnum.SCV_VEC:
                if (encodedSCVal.Vec != null)
                {
                    stream.WriteInt(1);
                    SCVec.Encode(stream, encodedSCVal.Vec);
                }
                else
                {
                    stream.WriteInt(0);
                }

                break;
            case SCValType.SCValTypeEnum.SCV_MAP:
                if (encodedSCVal.Map != null)
                {
                    stream.WriteInt(1);
                    SCMap.Encode(stream, encodedSCVal.Map);
                }
                else
                {
                    stream.WriteInt(0);
                }

                break;
            case SCValType.SCValTypeEnum.SCV_ADDRESS:
                SCAddress.Encode(stream, encodedSCVal.Address);
                break;
            case SCValType.SCValTypeEnum.SCV_LEDGER_KEY_CONTRACT_INSTANCE:
                break;
            case SCValType.SCValTypeEnum.SCV_LEDGER_KEY_NONCE:
                SCNonceKey.Encode(stream, encodedSCVal.NonceKey);
                break;
            case SCValType.SCValTypeEnum.SCV_CONTRACT_INSTANCE:
                SCContractInstance.Encode(stream, encodedSCVal.Instance);
                break;
        }
    }

    public static SCVal Decode(XdrDataInputStream stream)
    {
        var decodedSCVal = new SCVal();
        var discriminant = SCValType.Decode(stream);
        decodedSCVal.Discriminant = discriminant;
        switch (decodedSCVal.Discriminant.InnerValue)
        {
            case SCValType.SCValTypeEnum.SCV_BOOL:
                decodedSCVal.B = stream.ReadInt() == 1 ? true : false;
                break;
            case SCValType.SCValTypeEnum.SCV_VOID:
                break;
            case SCValType.SCValTypeEnum.SCV_ERROR:
                decodedSCVal.Error = SCError.Decode(stream);
                break;
            case SCValType.SCValTypeEnum.SCV_U32:
                decodedSCVal.U32 = Uint32.Decode(stream);
                break;
            case SCValType.SCValTypeEnum.SCV_I32:
                decodedSCVal.I32 = Int32.Decode(stream);
                break;
            case SCValType.SCValTypeEnum.SCV_U64:
                decodedSCVal.U64 = Uint64.Decode(stream);
                break;
            case SCValType.SCValTypeEnum.SCV_I64:
                decodedSCVal.I64 = Int64.Decode(stream);
                break;
            case SCValType.SCValTypeEnum.SCV_TIMEPOINT:
                decodedSCVal.Timepoint = TimePoint.Decode(stream);
                break;
            case SCValType.SCValTypeEnum.SCV_DURATION:
                decodedSCVal.Duration = Duration.Decode(stream);
                break;
            case SCValType.SCValTypeEnum.SCV_U128:
                decodedSCVal.U128 = UInt128Parts.Decode(stream);
                break;
            case SCValType.SCValTypeEnum.SCV_I128:
                decodedSCVal.I128 = Int128Parts.Decode(stream);
                break;
            case SCValType.SCValTypeEnum.SCV_U256:
                decodedSCVal.U256 = UInt256Parts.Decode(stream);
                break;
            case SCValType.SCValTypeEnum.SCV_I256:
                decodedSCVal.I256 = Int256Parts.Decode(stream);
                break;
            case SCValType.SCValTypeEnum.SCV_BYTES:
                decodedSCVal.Bytes = SCBytes.Decode(stream);
                break;
            case SCValType.SCValTypeEnum.SCV_STRING:
                decodedSCVal.Str = SCString.Decode(stream);
                break;
            case SCValType.SCValTypeEnum.SCV_SYMBOL:
                decodedSCVal.Sym = SCSymbol.Decode(stream);
                break;
            case SCValType.SCValTypeEnum.SCV_VEC:
                var VecPresent = stream.ReadInt();
                if (VecPresent != 0) decodedSCVal.Vec = SCVec.Decode(stream);
                break;
            case SCValType.SCValTypeEnum.SCV_MAP:
                var MapPresent = stream.ReadInt();
                if (MapPresent != 0) decodedSCVal.Map = SCMap.Decode(stream);
                break;
            case SCValType.SCValTypeEnum.SCV_ADDRESS:
                decodedSCVal.Address = SCAddress.Decode(stream);
                break;
            case SCValType.SCValTypeEnum.SCV_LEDGER_KEY_CONTRACT_INSTANCE:
                break;
            case SCValType.SCValTypeEnum.SCV_LEDGER_KEY_NONCE:
                decodedSCVal.NonceKey = SCNonceKey.Decode(stream);
                break;
            case SCValType.SCValTypeEnum.SCV_CONTRACT_INSTANCE:
                decodedSCVal.Instance = SCContractInstance.Decode(stream);
                break;
        }

        return decodedSCVal;
    }
}