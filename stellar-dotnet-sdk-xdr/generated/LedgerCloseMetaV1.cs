// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

namespace stellar_dotnet_sdk.xdr;

// === xdr source ============================================================

//  struct LedgerCloseMetaV1
//  {
//      // We forgot to add an ExtensionPoint in v0 but at least
//      // we can add one now in v1.
//      ExtensionPoint ext;
//  
//      LedgerHeaderHistoryEntry ledgerHeader;
//  
//      GeneralizedTransactionSet txSet;
//  
//      // NB: transactions are sorted in apply order here
//      // fees for all transactions are processed first
//      // followed by applying transactions
//      TransactionResultMeta txProcessing<>;
//  
//      // upgrades are applied last
//      UpgradeEntryMeta upgradesProcessing<>;
//  
//      // other misc information attached to the ledger close
//      SCPHistoryEntry scpInfo<>;
//  
//      // Size in bytes of BucketList, to support downstream
//      // systems calculating storage fees correctly.
//      uint64 totalByteSizeOfBucketList;
//  
//      // Temp keys that are being evicted at this ledger.
//      LedgerKey evictedTemporaryLedgerKeys<>;
//  
//      // Archived restorable ledger entries that are being
//      // evicted at this ledger.
//      LedgerEntry evictedPersistentLedgerEntries<>;
//  };

//  ===========================================================================
public class LedgerCloseMetaV1
{
    public ExtensionPoint Ext { get; set; }
    public LedgerHeaderHistoryEntry LedgerHeader { get; set; }
    public GeneralizedTransactionSet TxSet { get; set; }
    public TransactionResultMeta[] TxProcessing { get; set; }
    public UpgradeEntryMeta[] UpgradesProcessing { get; set; }
    public SCPHistoryEntry[] ScpInfo { get; set; }
    public Uint64 TotalByteSizeOfBucketList { get; set; }
    public LedgerKey[] EvictedTemporaryLedgerKeys { get; set; }
    public LedgerEntry[] EvictedPersistentLedgerEntries { get; set; }

    public static void Encode(XdrDataOutputStream stream, LedgerCloseMetaV1 encodedLedgerCloseMetaV1)
    {
        ExtensionPoint.Encode(stream, encodedLedgerCloseMetaV1.Ext);
        LedgerHeaderHistoryEntry.Encode(stream, encodedLedgerCloseMetaV1.LedgerHeader);
        GeneralizedTransactionSet.Encode(stream, encodedLedgerCloseMetaV1.TxSet);
        var txProcessingsize = encodedLedgerCloseMetaV1.TxProcessing.Length;
        stream.WriteInt(txProcessingsize);
        for (var i = 0; i < txProcessingsize; i++)
            TransactionResultMeta.Encode(stream, encodedLedgerCloseMetaV1.TxProcessing[i]);
        var upgradesProcessingsize = encodedLedgerCloseMetaV1.UpgradesProcessing.Length;
        stream.WriteInt(upgradesProcessingsize);
        for (var i = 0; i < upgradesProcessingsize; i++)
            UpgradeEntryMeta.Encode(stream, encodedLedgerCloseMetaV1.UpgradesProcessing[i]);
        var scpInfosize = encodedLedgerCloseMetaV1.ScpInfo.Length;
        stream.WriteInt(scpInfosize);
        for (var i = 0; i < scpInfosize; i++) SCPHistoryEntry.Encode(stream, encodedLedgerCloseMetaV1.ScpInfo[i]);
        Uint64.Encode(stream, encodedLedgerCloseMetaV1.TotalByteSizeOfBucketList);
        var evictedTemporaryLedgerKeyssize = encodedLedgerCloseMetaV1.EvictedTemporaryLedgerKeys.Length;
        stream.WriteInt(evictedTemporaryLedgerKeyssize);
        for (var i = 0; i < evictedTemporaryLedgerKeyssize; i++)
            LedgerKey.Encode(stream, encodedLedgerCloseMetaV1.EvictedTemporaryLedgerKeys[i]);
        var evictedPersistentLedgerEntriessize = encodedLedgerCloseMetaV1.EvictedPersistentLedgerEntries.Length;
        stream.WriteInt(evictedPersistentLedgerEntriessize);
        for (var i = 0; i < evictedPersistentLedgerEntriessize; i++)
            LedgerEntry.Encode(stream, encodedLedgerCloseMetaV1.EvictedPersistentLedgerEntries[i]);
    }

    public static LedgerCloseMetaV1 Decode(XdrDataInputStream stream)
    {
        var decodedLedgerCloseMetaV1 = new LedgerCloseMetaV1();
        decodedLedgerCloseMetaV1.Ext = ExtensionPoint.Decode(stream);
        decodedLedgerCloseMetaV1.LedgerHeader = LedgerHeaderHistoryEntry.Decode(stream);
        decodedLedgerCloseMetaV1.TxSet = GeneralizedTransactionSet.Decode(stream);
        var txProcessingsize = stream.ReadInt();
        decodedLedgerCloseMetaV1.TxProcessing = new TransactionResultMeta[txProcessingsize];
        for (var i = 0; i < txProcessingsize; i++)
            decodedLedgerCloseMetaV1.TxProcessing[i] = TransactionResultMeta.Decode(stream);
        var upgradesProcessingsize = stream.ReadInt();
        decodedLedgerCloseMetaV1.UpgradesProcessing = new UpgradeEntryMeta[upgradesProcessingsize];
        for (var i = 0; i < upgradesProcessingsize; i++)
            decodedLedgerCloseMetaV1.UpgradesProcessing[i] = UpgradeEntryMeta.Decode(stream);
        var scpInfosize = stream.ReadInt();
        decodedLedgerCloseMetaV1.ScpInfo = new SCPHistoryEntry[scpInfosize];
        for (var i = 0; i < scpInfosize; i++) decodedLedgerCloseMetaV1.ScpInfo[i] = SCPHistoryEntry.Decode(stream);
        decodedLedgerCloseMetaV1.TotalByteSizeOfBucketList = Uint64.Decode(stream);
        var evictedTemporaryLedgerKeyssize = stream.ReadInt();
        decodedLedgerCloseMetaV1.EvictedTemporaryLedgerKeys = new LedgerKey[evictedTemporaryLedgerKeyssize];
        for (var i = 0; i < evictedTemporaryLedgerKeyssize; i++)
            decodedLedgerCloseMetaV1.EvictedTemporaryLedgerKeys[i] = LedgerKey.Decode(stream);
        var evictedPersistentLedgerEntriessize = stream.ReadInt();
        decodedLedgerCloseMetaV1.EvictedPersistentLedgerEntries = new LedgerEntry[evictedPersistentLedgerEntriessize];
        for (var i = 0; i < evictedPersistentLedgerEntriessize; i++)
            decodedLedgerCloseMetaV1.EvictedPersistentLedgerEntries[i] = LedgerEntry.Decode(stream);
        return decodedLedgerCloseMetaV1;
    }
}